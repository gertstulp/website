{
  "hash": "a7879f9fb599aeaa7b17bb3695608254",
  "result": {
    "markdown": "---\ntitle: \"Recreating density plots 'by hand'\"\ndescription: |\n  Where I attempt to understand density plots and get stuck on Fast Fourier Transforms.   \ncategories:\n  - R\n  - Visualisation\nauthor: \"Gert Stulp\"\ndate: '2023-08-24'\ntoc: true\nimage: ../../images/density_blog.png\nimage-alt: I still have to find a figure for this. \nlanguage: \n    section-title-footnotes: References\n---\n\n\nOften, in my visualisations, I use density plots in one way or another, for example through violin plots. I roughly understand what they mean, but I want to be able to calculate a density plot by hand. Just the once, so I will never have to do it again, and know that *in principle* I will be able to do it. Learning about them also helps in understanding the distinctions between `dunif`, `punif`, `qunif`, and `runif` (or `dnorm`, `pnorm`, `qnorm`, and `rnorm` or `dexp`, `pexp`, `qexp`, and `rexp` et cetera)\n\n## Understanding the uniform (density) distribution\n\n### density(min = 0, max = 1)\n\nWhen generating generating random numbers we often do so from a uniform distribution between 0 and 1. Any number between 0 and 1 occurs equally frequently. As we learn from `?qunif`, the density function of the uniform distribution is described by:\n\n$$f(x) = \\frac{1}{max(x) - min(x)}$$\n\nThus, the density function in this case, for all x's is $f(\\text{for all x}) = \\frac{1}{1 - 0} = \\frac{1}{1} = 1$ (I am pretty sure there exists a mathematical symbol for \"for all x\", but I do not know it). Let's draw the function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\ndf <- data.frame(\n  x = c(0, 1),\n  density = 1\n) \n\ndens0_1 <- ggplot(df, aes(x = x, y = density)) +\n  geom_line(colour = '#67a9cf') +\n  annotate(\"text\", x = 0, y = 1, label = \"density(0, 1)\", \n           colour = '#67a9cf', hjust = 0, vjust = 1.2) +\n  scale_x_continuous(breaks = seq(0, 1, 0.1)) +\n  theme_classic()\ndens0_1\n```\n\n::: {.cell-output-display}\n![](2023-08-24-density-plots_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\nBy definition, for any density curve, the sum under the area of the \"curve\" adds up to 1. Let's check: the total area under the curve is the width, which equals 1 (from 0 to 1) times the height, which also equals 1 (for all x); thus, 1 x 1 is 1. Score! \n\n`R` could have told us this through: \n\n::: {.cell}\n\n```{.r .cell-code}\npunif(1, min = 0, max = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\nNow, something *slightly* more complex. What is the chance of having a number between 0.7 and 0.8?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndens0_1 <- dens0_1 +\n  geom_area(aes(x = c(0.7, 0.8), y = c(1, 1)), fill = '#67a9cf', alpha = 0.9) \n\ndens0_1 +\n  geom_segment(aes(x = 0.7, xend = 0.8, y = 0.02, yend = 0.02),\n                  arrow = arrow(ends = \"both\", type = \"closed\", \n                                length = unit(0.2, \"cm\")), colour = \"grey\") +\n  geom_segment(aes(x = 0.82, xend = 0.82, y = 0, yend = 1),\n                  arrow = arrow(ends = \"both\", type = \"closed\", \n                                length = unit(0.2, \"cm\")), colour = \"grey\") +\n  annotate(\"text\", x = 0.75, y = 0, label = \"0.1\", vjust = 1) +\n  annotate(\"text\", x = 0.82, y = 0.5, label = \"1\", hjust = 0) \n```\n\n::: {.cell-output-display}\n![](2023-08-24-density-plots_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nThe area under the curve is 0.1 * 1 = 0.1. Through `R`, this could have been calculated via:\n\n::: {.cell}\n\n```{.r .cell-code}\npunif(0.8, min = 0, max = 1) - punif(0.7, min = 0, max = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1\n```\n:::\n:::\n\n\n### density(min = 1, max = 5)\n\nOk, so what if we had used a density function from 1 to 5? Thus, the density function in this case, for all x's is $f(\\text{for all x}) = \\frac{1}{5 - 1} = \\frac{1}{4} = 0.25$. The area under the curve should be 1: the area under the curve from density(min = 1, max = 5) is the width (from 1 to 5 is a width of 4) times height (0.25 for all); thus, 4 x 0.25 = 1. Check.\n\nLet's draw this function in the same graph, and let's also draw the area under the curve between x = 3 and x = 4:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf2 <- data.frame(\n  x = c(1, 5),\n  density = c(0.25, 0.25)\n) \n\ndens0_1 +\n  geom_line(data = df2, colour = '#ef8a62') +\n  annotate(\"text\", x = 1, y = 0.25, label = \"density(1, 5)\", \n           colour = '#ef8a62', hjust = 0, vjust = 1.2) +\n  geom_area(aes(x = c(3, 4), y = c(0.25, 0.25)), fill = '#ef8a62', alpha = 0.9) +\n  geom_segment(aes(x = 3, xend = 4, y = 0.02, yend = 0.02),\n                   arrow = arrow(ends = \"both\", type = \"closed\",\n                                 length = unit(0.2, \"cm\")), colour = \"grey\") +\n  geom_segment(aes(x = 4.1, xend = 4.1, y = 0, yend = 0.25),\n                   arrow = arrow(ends = \"both\", type = \"closed\",\n                                length = unit(0.2, \"cm\")), colour = \"grey\") +\n  annotate(\"text\", x = 3.5, y = 0, label = \"1\", vjust = 1) +\n  annotate(\"text\", x = 4.1, y = 0.125, label = \"0.25\", hjust = 0) +\n  scale_x_continuous(breaks = seq(0, 5, 1)) +\n  scale_y_continuous(breaks = seq(0, 1, 0.25),\n                     limits = c(-0.015, 1)) \n```\n\n::: {.cell-output-display}\n![](2023-08-24-density-plots_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nThe area under the curve from density(min = 1, max = 5), and the relative frequency of having a number between 3 and 4, is the width (from 3 to 4 is a width of 1) times height (0.25 for all); thus, 1 x 0.25 = 0.25. 25%. Makes sense.\n\n`R` would have gotten this for us through:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npunif(4, min = 1, max = 5) - punif(3, min = 1, max = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.25\n```\n:::\n:::\n\n\n### dunif vs punif vs qunif vs runif\n\nFor the uniform function, we calculated the density ourselves which is identical for each \"x\". We could have let `R` do this for us using `dunif`:\n\nFor the uniform(min = 0, max = 1) distribution:\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- seq(0, 1, 0.1) # for each step of 0.1 between values 0 and 1\n# calculate density\ndunif(x, min = 0, max = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 1 1 1 1 1 1 1 1 1 1\n```\n:::\n:::\n\n\nFor the uniform(min = 1, max = 5) distribution:\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- seq(0, 5, 1) # for each step of 1 between values 0 and 5\n# calculate density\ndunif(x, min = 1, max = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.00 0.25 0.25 0.25 0.25 0.25\n```\n:::\n:::\n\n\n0 for x = 0, as it should! \n\nWe've already seen `punif` in action, but let's see it again. Let's find out the probability that a number is between 0 and 0.35 for the uniform(min = 0, max = 1) distribution:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npunif(q = 0.35, min = 0, max = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.35\n```\n:::\n:::\n\n\nAnd let's find out the probability that a number is between 2.5 and 4.2 for the uniform(min = 1, max = 5) distribution:\n\n::: {.cell}\n\n```{.r .cell-code}\npunif(q = 4.2, min = 1, max = 5) - # probability for numbers between 1 and 4.2 \n  punif(q = 3.5, min = 1, max = 5) # probability for numbers between 1 and 2.5 \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.175\n```\n:::\n:::\n\n\nThe `qunif` function goes from a probability back to the \"x\". For example, which \"x\" corresponds to a probability of 0.5. Thus, which area under the curve, starting from the minimum of x to the x we are looking for equals 0.5. \n\nFor the unif(min = 0, max = 1) distribution:\n\n::: {.cell}\n\n```{.r .cell-code}\nqunif(p = 0.5, min = 0, max = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5\n```\n:::\n:::\n\n\nFor the unif(0.5, min = 1, max = 5) distribution:\n\n::: {.cell}\n\n```{.r .cell-code}\nqunif(p = 0.5, min = 1, max = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\nOr let's say we are interested in the top 1% of x's from the `unif(min = 1, max = 5)` distribution:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqunif(p = 0.99, min = 1, max = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4.96\n```\n:::\n:::\n\n\n4.96 and higher! This *might* make more sense when we talk about the normal distribution (`qnorm`).\n\n`runif` lets you draw random numbers from said distribution. Let's draw 11 numbers from the `unif(min = 1, max = 5)` distribution:\n\n::: {.cell}\n\n```{.r .cell-code}\nrunif(n = 11, min = 1, max = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 2.201886 3.594314 1.285670 1.266898 1.843133 3.455094 1.605378 3.898504\n [9] 4.929507 3.570989 3.762690\n```\n:::\n:::\n\n\nAlright, easy enough. Let's move to the (standard) normal distribution, because that is the one that is used for violinplots and the like. \n\n## Understanding the normal (density) distribution\n\nThe normal distribution is defined by the mean ($\\mu$) and the standard deviation ($\\sigma$), and its density distribution (better yet: probability density function) is defined by:\n\n$$f(x) = \\frac{1}{{\\sigma \\sqrt {2\\pi } }}e^{{{ -( {x - \\mu })^2} / 2\\sigma^2} }$$\nWith the standard normal distribution, $\\mu = 0$ and $\\sigma = 1$, in which case the above function reduces to:\n\n$$f(x) = \\frac{1}{{\\sqrt {2\\pi } }}e^{{{ -\\frac{1}{2}x} } }$$\nLet's turn the probability density function for a normal distribution into an `R`-function:\n\n::: {.cell}\n\n```{.r .cell-code}\npdf_norm <- function(x, mean = 0, sd = 1) {\n  (1 / (sd * sqrt( 2 * pi ))) * exp( (-1 * (x - mean)^2) / (2 * sd^2)  )\n}\n```\n:::\n\n\nLet's see if it works:\n\n::: {.cell}\n\n```{.r .cell-code}\npdf_norm(0, mean = 0, sd = 1) # obviously mean = 0, sd = 1 not necessary\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.3989423\n```\n:::\n:::\n\n\nLet's draw it:\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tibble)\n# I use tibble here so that y can be calculated immediately\ndf_norm <- tibble(x = seq(-5, 5, 0.01), density = pdf_norm(x))\n\ndens_norm <- ggplot(df_norm, aes(x = x, y = density)) +\n  geom_path(colour = '#67a9cf', size = 3) + \n  theme_classic()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n```\n:::\n\n```{.r .cell-code}\ndens_norm\n```\n\n::: {.cell-output-display}\n![](2023-08-24-density-plots_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# c(, '#ef8a62')\n```\n:::\n\nWe've created our own probability density function for the normal distribution in `pdf_norm`, but we did not have to because this is exactly what is stored in the function `dnorm`. Let's see:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create y-values on the base of dnorm\ndf_norm2 <- tibble(x = seq(-5, 5, 0.01), \n                   density = dnorm(x, mean = 0, sd = 1))\n\ndens_norm +\n  geom_path(data = df_norm2, \n            aes(y = density), colour = '#ef8a62', linetype = \"dashed\", size = 3)\n```\n\n::: {.cell-output-display}\n![](2023-08-24-density-plots_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\nNow, through `dnorm`, we can calculate the highest density value which lies at x = 0:\n\n::: {.cell}\n\n```{.r .cell-code}\ndnorm(x = 0, mean = 0, sd = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.3989423\n```\n:::\n:::\n\n\nLet's visualise:\n\n::: {.cell}\n\n```{.r .cell-code}\n# We're using the results from dnorm here (y2)\ndens_norm2 <- ggplot(df_norm2, aes(x = x, y = density)) +\n  geom_path(colour = '#ef8a62', size = 2) +\n  scale_x_continuous(breaks = seq(-5, 5, 1)) + \n  theme_classic()\n\ndens_norm2 + \n  annotate(\"point\", x = 0, y = dnorm(x = 0, mean = 0, sd = 1), \n           colour = '#67a9cf') +\n  annotate(\"text\", x = 0, y = dnorm(x = 0, mean = 0, sd = 1), \n           label = dnorm(x = 0, mean = 0, sd = 1), vjust = 0, colour = '#67a9cf') \n```\n\n::: {.cell-output-display}\n![](2023-08-24-density-plots_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\nNow, we can look for probabilities. This time, probabilities under the curve are not as easily calculated by hand, but we've seen above that we could get these probabilities through `punif` for the uniform distribution, and in the same way we can use `pnorm` to find probabilities for the normal distribution! Let's try finding the probability of finding an x equal to or below -1:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npnorm(q = -1, mean = 0, sd = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1586553\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndens_norm2 +\n  geom_area(data = subset(df_norm2, x <= -1), \n            fill = '#ef8a62', alpha = 0.7) +\n  annotate(\"text\", x = -1, y = 0.05, \n           label = round(pnorm(q = -1, mean = 0, sd = 1), 4), \n           hjust = 1, colour = \"white\") \n```\n\n::: {.cell-output-display}\n![](2023-08-24-density-plots_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\nOr between 0 and 2:\n\n::: {.cell}\n\n```{.r .cell-code}\np_0_2 <- pnorm(q = 2, mean = 0, sd = 1) - pnorm(q = 0, mean = 0, sd = 1)\np_0_2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.4772499\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndens_norm2 +\n  geom_area(data = subset(df_norm, x >= 0 & x <= 2), \n            fill = '#ef8a62', alpha = 0.7) +\n  annotate(\"text\", x = 1, y = 0.05, \n           label = round(p_0_2, 4), colour = \"white\") \n```\n\n::: {.cell-output-display}\n![](2023-08-24-density-plots_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n## Density plots\n\nWe've did the ground work for the density plots. Now we try to understand how we get something like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_dens <- data.frame(x = c(0, 0.3, 1))\nggplot(df_dens, aes(x = x), colour = '#67a9cf', size = 2) +\n  geom_density() +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](2023-08-24-density-plots_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\nIt's important to realise that under hood something like this happens:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(df_dens, aes(x = x)) +\n  geom_density(\n    kernel = \"gaussian\",\n    bw = \"nrd0\",\n    colour = '#67a9cf',\n    size = 2\n  ) +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](2023-08-24-density-plots_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\nThese arguments (`kernel = \"gaussian\"` and `bw = \"nrd0\"`) are passed to the function `density()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndensity(x = df_dens$x, kernel = \"gaussian\", bw = \"nrd0\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\n\tdensity.default(x = df_dens$x, bw = \"nrd0\", kernel = \"gaussian\")\n\nData: df_dens$x (3 obs.);\tBandwidth 'bw' = 0.2696\n\n       x                 y           \n Min.   :-0.8087   Min.   :0.005535  \n 1st Qu.:-0.1544   1st Qu.:0.103430  \n Median : 0.5000   Median :0.447735  \n Mean   : 0.5000   Mean   :0.381337  \n 3rd Qu.: 1.1544   3rd Qu.:0.545436  \n Max.   : 1.8087   Max.   :0.848818  \n```\n:::\n\n```{.r .cell-code}\n# same as density(x = df_dens$x)\n```\n:::\n\nJust to show that `density` leads to the same graph as `geom_density`:\n\n::: {.cell}\n\n```{.r .cell-code}\ndens_calc <- density(x = df_dens$x)\ndf_dens2 <- data.frame(x = dens_calc$x, density = dens_calc$y)\n\nggplot(df_dens, aes(x = x)) +\n  geom_density(colour = '#67a9cf', size = 2) +\n  geom_density(data = df_dens2, stat = \"identity\", \n               aes(x = x, y = density),\n               colour = '#ef8a62', size = 2, linetype = \"dashed\") +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](2023-08-24-density-plots_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\nTo arrive at these results, it is important to understand the `kernel = \"gaussian\"` and `bw = \"nrd0\"` arguments. \n\n## Kernel density distributions\nThe density estimation happens through something called a a kernel density distribution. This is defined by:\n\n$$ \\hat{f}_{h}(x)=\\frac{1}{nh}\\sum_{i=1}^nK(\\frac{x-x_i}{h}) $$\n\nIn the above function, `K`, is the kernel, some non-negative density distribution function, like the ones we have defined above. `h` is the bandwidth, a positive number that effectively defines the smoothness of the graph. The argument `kernel =` refers to `K` and the argument `bw = ` refers to the bandwidth `h`. As you might guess, the `kernel = gaussian\"` says that we are using the gaussian or normal density distribution as the kernal `K`!\n\nAt this point, I was still a bit lost, but following this [great blogpost](https://aakinshin.net/posts/kde-bw/) I understood more. Let's first assume a bandwidth of 1, and a sample of three numbers from a population {5, 7, 8}. \n\nTo build a kernel density estimation (using the normal density distribution) for a sample, we need to perform two steps:\n\n1) For each element in the sample, draw a normal distribution where the sample element is the mean, and the variance is defined by the square of the bandwidth, $h^2$.\n\n2) Sum up all the normal distributions from step 1 and divide the sum by `nh`, which is equal to `n` in this case, because we defined the bandwidth as 1. \n\nSo, below we'll plot three normal distributions: $\\mathcal{N}(5, 1)$, $\\mathcal{N}(7, 1)$, and $\\mathcal{N}(8, 1)$, plus its sum divided by three (`nh`) to arrive at the overall density distribution. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(\n  x = seq(0, 15, 0.01),\n  norm_5 = dnorm(x, mean = 5, sd = 1),\n  norm_7 = dnorm(x, mean = 7, sd = 1),\n  norm_8 = dnorm(x, mean = 8, sd = 1),\n  norm_sum = (norm_5 + norm_7 + norm_8) / 3\n)\n\nkernel <- ggplot(df, aes(x = x)) +\n  geom_line(aes(y = norm_5), colour = '#ef8a62', size = 2) +\n  geom_line(aes(y = norm_7), colour = \"#a83299\", size = 2) +\n  geom_line(aes(y = norm_8), colour = '#67a9cf', size = 2) +\n  geom_line(aes(y = norm_sum), colour = \"darkgrey\", size = 2) +\n  labs(y = \"density\") +\n  theme_classic()\nkernel\n```\n\n::: {.cell-output-display}\n![](2023-08-24-density-plots_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n\nHow does this one stack up to the `geom_density'-distribution? \n\n\n::: {.cell}\n\n```{.r .cell-code}\nkernel +\n  geom_density(\n    data = data.frame(x = c(5, 7, 8)),\n    bw = 1, # remember we used a bandwidth of 1!\n    colour = '#f7f7f7', linetype = \"dashed\", size = 2\n  )\n```\n\n::: {.cell-output-display}\n![](2023-08-24-density-plots_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\nSUCCESS! \n\nHowever, normally we would have `geom_density` calculate the bandwidth (`bw`) for us. Let's see\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = data.frame(x = c(5, 7, 8)), aes(x = x)) +\n  geom_density(bw = 1, colour = \"darkgrey\", size = 2) +\n  geom_density(size = 2) + # currently unknown bandwidth\n  theme_classic() +\n  scale_x_continuous(limits = c(0, 15))\n```\n\n::: {.cell-output-display}\n![](2023-08-24-density-plots_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n:::\n\nSimilar but not the same, and that's because a different binwidth is used. Which binwidth? `geom_density` uses `density`. So let's see what density gives us:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndensity(x = c(5, 7, 8))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\n\tdensity.default(x = c(5, 7, 8))\n\nData: c(5, 7, 8) (3 obs.);\tBandwidth 'bw' = 0.8087\n\n       x                y           \n Min.   : 2.574   Min.   :0.001845  \n 1st Qu.: 4.537   1st Qu.:0.033991  \n Median : 6.500   Median :0.151694  \n Mean   : 6.500   Mean   :0.127113  \n 3rd Qu.: 8.463   3rd Qu.:0.185661  \n Max.   :10.426   Max.   :0.273176  \n```\n:::\n:::\n\n\nSo a bandwidth equal to 0.8087322. Let's validate:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = data.frame(x = c(5, 7, 8)), aes(x = x)) +\n  geom_density(bw = density(x = c(5, 7, 8))$bw, \n               colour = \"darkgrey\", size = 2) +\n  geom_density(size = 2, linetype = \"dashed\") + # currently unknown bandwidth\n  theme_classic() +\n  scale_x_continuous(limits = c(0, 15))\n```\n\n::: {.cell-output-display}\n![](2023-08-24-density-plots_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n:::\n\nSuccess, yet again. \n\nHow did `geom_density`, or better yet `density` arrive at 0.8087322? This is where the other argument `bw = \"nrd0\"` comes in. When using `density(kernel = \"gaussian\")`, the default way to estimate the bandwidth is through the argument `bw = \"nrd0\"`. The help function further tells us that: \n\n> \"bw.nrd0 implements a rule-of-thumb for choosing the bandwidth of a Gaussian kernel density estimator. It defaults to 0.9 times the minimum of the standard deviation and the interquartile range divided by 1.34 times the sample size to the negative one-fifth power (= Silverman's ‘rule of thumb’, Silverman (1986, page 48, eqn (3.31))) unless the quartiles coincide when a positive result will be guaranteed.\"\n\nNot exactly beautiful prose. Anyway, Silverman's rule of thumb is:\n\n$$b = 0.9 \\cdot min(\\hat{\\sigma}, \\frac{IQR}{1.35})n^{-\\frac{1}{5}}$$\nLet's see if we can calculate it ourselves. \n\n::: {.cell}\n\n```{.r .cell-code}\nsd <- sd(c(5, 7, 8))\nQ3 <- quantile(c(5, 7, 8), 0.75)\nQ1 <- quantile(c(5, 7, 8), 0.25)\nIQR <- Q3 - Q1 \nIQR_div <- IQR / 1.34\nh_calc <- (0.9 * IQR_div) * 3^(-1/5)\n```\n:::\n\n\nThe (sample) standard deviation of 5, 7, and 8 is 1.5275252. \n\nThe IQR is Q3 - Q1 = 7.5 - 6 = 1.5. [in R there are nine different ways to produce quantiles via the `quantile` function. Sigh.]. The IQR divided by 1.34 is 1.119403. Thus, the IQR/1.34 is smaller than the standard deviation. Thus, \n\n$b = 0.9 \\cdot 1.119403  \\cdot n^{-\\frac{1}{5}}$ = 0.8087322.\n\n![](../../images/yaaay-saturday-night-live.gif){width=30%}\n\n\n[ Let us completely ignore that using the Silverman's rule of thumb is [ill-advised](https://aakinshin.net/posts/kde-bw/) ]\n\n### Are we there yet?\n\nNO. We've calculated the overall density distributions through the density function of the normal distribution, and we seem to be getting the exact same results. *However*, under the hood, the `density()` function is using Fast Fourier Transform [signal processing course nightmares]. [This great video](https://www.youtube.com/watch?v=wv7CWZIVkrQ) (which I understand let's say 73%) explains that a Fast Fourier Transform of a normal distribution is a normal distribution. So I guess it is not weird when we get the same (similar?) results when using the normal density distributions to calculate use as a Kernel. I have reached the limits of my cognitive abilities, so I will not explore this further currently.   \n\nI would have not been able to write this post that nobody reads without this [blog](https://aakinshin.net/posts/kde-bw/).",
    "supporting": [
      "2023-08-24-density-plots_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}